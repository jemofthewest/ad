#include "mex.h"
#include "matrix.h"
#include "dbg.h"

/*
 * tapenadeWrapper.c
 * This is a wrapper for using automatically generated C code from Tapenade in fmin.
 *
 * This is a MEX-file for MATLAB.
 *
 */

/*        Generated by TAPENADE     (INRIA, Tropics team)
    Tapenade 3.7 (r4781) - 21 Feb 2013 13:50
*/

/*
  Differentiation of rosenbrock in forward (tangent) mode:
   variations   of useful results: rosenbrock
   with respect to varying inputs: x[_:_]
   RW status of diff variables: x[_:_]:in rosenbrock:out
   Plus diff mem management of: x:in
*/
double rosenbrock_d(double x[], double xd[], mwSize n, double *rosenbrock) {
    double f,fd;
    mwSize i;

    f = 0.0;
    fd = 0.0;

    for (i = 0; i < n-1; ++i) {
        fd = fd + 100*((xd[i]*x[i]+x[i]*xd[i]-xd[i+1])*(x[i]*x[i]-x[i+1])) + 
            100*((x[i]*x[i]-x[i+1])*(xd[i]*x[i]+x[i]*xd[i]-xd[i+1])) + xd[i]*(
            x[i]-1) + (x[i]-1)*xd[i];
        f = f + 100*(x[i]*x[i]-x[i+1])*(x[i]*x[i]-x[i+1]) + (x[i]-1)*(x[i]-1);
    }

    *rosenbrock = f;
    return fd;
}

/* Gateway Function */
void mexFunction( int nlhs, mxArray *plhs[],
                  int nrhs, const mxArray *prhs[])
{
  double *x, **xd;
  double *f, *fd;
  mwSize n,i,j;

  /* check for proper number of arguments */
  if (nrhs != 1) {
    mexErrMsgIdAndTxt("Tapenade:jacobian:nrhs",
        "Wrong number of inputs.");
  }
  if (nlhs != 2) {
    mexErrMsgIdAndTxt("Tapenade:jacobian:nlhs",
        "Wrong number of outputs.");
  }

  /* typechecking */
  if (mxGetM(prhs[0]) != 1 || 
      mxIsComplex(prhs[0]) ||
      !mxIsDouble(prhs[0])) {
    mexErrMsgIdAndTxt("Tapenade:jacobian:rhsType",
        "Input must be row vector");
  }

  /* claim inputs */
  x = mxGetPr(prhs[0]);
  n = mxGetN(prhs[0]);

  /* prepare outputs */
  fd = mxCalloc (n, sizeof(double));
  check(fd, "fd alloc failed");

  xd = mxCalloc (n, sizeof(double*));
  check(xd, "xd alloc failed");
  for (i = 0; i < n; i++) {
    xd[i] = mxCalloc (n, sizeof(double));  
    check(xd[i], "xd at %f failed", i);
  }

  plhs[0] = mxCreateDoubleMatrix ((mwSize) 1, (mwSize) 1, mxREAL);
  plhs[1] = mxCreateDoubleMatrix ((mwSize) 1, n, mxREAL);

  f = mxGetPr(plhs[0]);

  /* directional unit vectors */
  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      xd[i][j] = 0.0;
    }
  }

  for (i = 0; i < n; i++) {
    xd[i][i] = 1.0;
  }

  for (i = 0; i < n; i++) {
    fd[i] = rosenbrock_d(x, xd[i], n, f);
  }

  mxSetPr(plhs[1], fd);
error:
  if (fd) mxFree(fd);
  if (xd) {
    for (i = 0; i < n; i++) {
      if (xd[i]) mxFree(xd[i]);
    }
    mxFree(xd);
  }
}
